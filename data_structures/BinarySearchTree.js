// Унифицированная структура одного элемента cтэка Stack
class Node {
  constructor(value) {
    // Само значение у элемента
    this.value = value;
    // Левый и правый варианты связующих ссылок. По умолчанию - null (пустые)
    this.left = null;
    this.right = null;
  }
}

class BinarySearchTree {
  // Инициализация корня дерева, от которого оно будет разростатся
  constructor() {
    this.root = null;
  }

  // Добавление данных в дерево
  insert(value) {
    // Каждый элемент дерева является экземпляром класса Node
    const newNode = new Node(value);
    // Если дерево пустое, то новый элемент будет первым элементом
    if (this.root === null) {
      this.root = newNode;
      // Вернуть новый объект дерева
      return this;
    }

    // Добавление маркера temp для создания дистанцированного различия
    // между новым элементом, который лежит не в корне и самим корневым элементом
    let temp = this.root;
    // В цикле проитерируемся, чтобы разместить непосредственно сам элемент в дереве
    while (true) {
      if (newNode.value === temp.value) return undefined;
      // Если значение нового элемента ниже значения существующего
      // элемента - переместить элемент влево
      if (newNode.value < temp.value) {
        // При этом если левая ссылка на следующий элемент у итерируемого элемента пуста,
        // тогда новый элемент замещается и привязывается по этой ссылке в дерево
        if (temp.left === null) {
          temp.left = newNode;
          return this;
        }
        // Если существует ссылка на левый элемент, тогда присвоить маркеру temp этот объект и повторить цикл
        temp = temp.left;
        // Иначе внедрить объект в правую сторону дерева
      } else {
        // При этом если правая ссылка на следующий элемент у итерируемого элемента пуста,
        // тогда новый элемент замещается и привязывается по этой ссылке в дерево
        if (temp.right === null) {
          temp.right = newNode;
          return this;
        }
        // Если существует ссылка на правый элемент, тогда присвоить маркеру temp этот объект и повторить цикл
        temp = temp.right;
      }
    }
  }

  // Проверка на наличие значения в дереве
  contains(value) {
    // Если дерево пустое вернуть false
    if (this.root === null) return false;
    // Добавление маркера temp для создания дистанцированного различия
    // между новым элементом, который лежит не в корне и самим корневым элементом
    let temp = this.root;
    while (temp) {
      // Если значение нового элемента ниже значения существующего
      // элемента - переместить поиск на следующий, левый, элемент дерева и повторить поиск
      if (value < temp.value) {
        temp = temp.left;
        // Если значение нового элемента ниже значения существующего
        // элемента - переместить поиск на следующий, правый, элемент дерева и повторить поиск
      } else if (value > temp.value) {
        temp = temp.right;
      } else {
        // Если элемент был найден, вернуть true
        return true;
      }
    }
    // Иначе вернуть false
    return false;
  }

  // Вернуть минимальное значение исходя из расположения элемента в дереве
  minValueNode(currentNode) {
    // Поскольку минимальные значения всегда в дереве отсылаются влево,
    // то и поиск минимального значения следует производить в левой части дерева.
    // Если связующая ссылка на следующий элемент существует, тогда присвоить поисковому
    //элементу ссылки на следующий, левый, элемент и так повторять в цикле, до тех пор пока ссылка не будет Null
    while (currentNode.left != null) {
      currentNode = currentNode.left;
    }
    // Если ссылка была найдена - вернуть этот элемент
    return currentNode;
  }
}
